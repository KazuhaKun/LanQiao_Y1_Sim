C51 COMPILER V9.54   MAIN                                                                  04/08/2025 20:37:04 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /***************************************************************************************
   2          * Copyright (C) 2025 ç±³é†‹ç”µå­å·¥ä½œå®¤
   3          *
   4          * ç‰ˆæœ¬         ï¼šV4T
   5          * ä½œè€…         ï¼šç±³é†‹ç”µå­å·¥ä½œå®¤
   6          * æè¿°         ï¼šè¯¥ç‰ˆæœ¬ä¸ºV2ç‰ˆæœ¬çš„æ”¹è¿›ç‰ˆï¼Œé’ˆå¯¹4Tå¹³å°åšäº†ä¸“é¡¹ä¼˜åŒ–ï¼Œä¿®å¤äº†æ­¤å‰ç
             -‰ˆæœ¬çš„è‹¥å¹²Bug
   7          *
   8          * ç‰ˆæƒå½’ç±³é†‹ç”µå­å·¥ä½œå®¤æ‰€æœ‰ï¼Œå¹¶ä¿ç•™æ‰€æœ‰æƒåŠ›ã€‚
   9          * æœªç»æ˜ç¡®ä¹¦é¢è®¸å¯ï¼Œä»»ä½•ä¸ªäººæˆ–æœºæ„ä¸å¾—æ“…è‡ªç”¨äºå•†ä¸šç”¨é€”ã€‚
  10          ***********************************************************************************************/
  11          
  12          /* å¤´æ–‡ä»¶å£°æ˜åŒº */
  13          #include <STC15F2K60S2.H>//å•ç‰‡æœºå¯„å­˜å™¨ä¸“ç”¨å¤´æ–‡ä»¶
  14          #include <Init.h>//åˆå§‹åŒ–åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
  15          #include <Led.h>//Ledåº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
  16          #include <Key.h>//æŒ‰é”®åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
  17          #include <Seg.h>//æ•°ç ç®¡åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
  18          #include <Uart.h>//ä¸²å£åº•å±‚é©±åŠ¨ä¸“ç”¨å¤´æ–‡ä»¶
  19          #include <string.h>
  20          #include <iic.h>
  21          #include <ds1302.h>
  22          #include <onewire.h>
  23          /* å˜é‡å£°æ˜åŒº */
  24          unsigned char Key_Val,Key_Down,Key_Old,Key_Up;//æŒ‰é”®ä¸“ç”¨å˜é‡
  25          unsigned char Key_Slow_Down;//æŒ‰é”®å‡é€Ÿä¸“ç”¨å˜é‡
  26          unsigned char Seg_Buf[8] = {10,10,10,10,10,10,10,10};//æ•°ç ç®¡æ˜¾ç¤ºæ•°æ®å­˜æ”¾æ•°ç»„
  27          unsigned char Seg_Pos;//æ•°ç ç®¡æ‰«æä¸“ç”¨å˜é‡
  28          idata unsigned int Seg_Slow_Down;//æ•°ç ç®¡å‡é€Ÿä¸“ç”¨å˜é‡
  29          idata unsigned char L3_Count=0;
  30          idata unsigned char ucLed[8] = {0,0,0,0,0,0,0,0};//Ledæ˜¾ç¤ºæ•°æ®å­˜æ”¾æ•°ç»„
  31          idata unsigned char Uart_Slow_Down;//ä¸²å£å‡é€Ÿä¸“ç”¨å˜é‡
  32          idata unsigned char Uart_Recv[10];//ä¸²å£æ¥æ”¶æ•°æ®å‚¨å­˜æ•°ç»„ é»˜è®¤10ä¸ªå­—èŠ‚ è‹¥æ¥æ”¶æ•°æ®è¾ƒé•¿
             - å¯æ›´æ”¹æœ€å¤§å­—èŠ‚æ•°
  33          idata unsigned char Uart_Recv_Index;//ä¸²å£æ¥æ”¶æ•°ç»„æŒ‡é’ˆ
  34          idata unsigned char Uart_Send[10];//ä¸²å£æ¥æ”¶æ•°æ®å‚¨å­˜æ•°ç»„ é»˜è®¤10ä¸ªå­—èŠ‚ è‹¥å‘é€æ•°æ®è¾ƒé•¿
             - å¯æ›´æ”¹æœ€å¤§å­—èŠ‚æ•°
  35          /* ä¸²å£æ•°æ® */
  36          pdata unsigned char Uart_Buf[10] = {0}; // ä¸²å£æ¥æ”¶ç¼“å†²åŒº
  37          idata unsigned char Uart_Rx_Index;      // ä¸²å£æ¥æ”¶ç´¢å¼•
  38          idata unsigned char Uart_Recv_Tick;     // ä¸²å£æ¥æ”¶æ—¶é—´æ ‡å¿—
  39          idata unsigned char Uart_Rx_Flag;
  40          /* åæ ‡å˜é‡ */
  41          unsigned int X,Y;
  42          unsigned int X_Set,Y_Set;
  43          /* æ¨¡å¼æ ‡å¿— */
  44          unsigned char Seg_Mode=0; //0åæ ‡ 1é€Ÿåº¦ 2å‚æ•°
  45          unsigned char Run_Status=0;  //0ç©ºé—² 1è¿è¡Œ 2ç­‰å¾…
  46          /* é€Ÿåº¦ */
  47          unsigned int Speed,Speed_Disp;
  48          /* è·ç¦» */
  49          unsigned int Juli;
  50          bit Wait_Flag;
  51          /* å‚æ•° */
C51 COMPILER V9.54   MAIN                                                                  04/08/2025 20:37:04 PAGE 2   

  52          unsigned char _R=10;
  53          char _B=0;
  54          bit p_mode=0; // 0R 1B
  55          /* LEDé—ªçƒæ ‡å¿—ä½ */
  56          bit Flash_Flag=0;
  57          /* æ—¥å¤œåœºæ™¯æ ‡å¿—ä½ */
  58          bit Night_Flag=0;
  59          /* åˆ°è¾¾æ ‡å¿—ä½ */
  60          bit Arv_Flag=0;
  61          
  62          /* é”®ç›˜å¤„ç†å‡½æ•° */
  63          void Key_Proc()
  64          {
  65   1        if(Key_Slow_Down<10) return;
  66   1        Key_Slow_Down = 0;//é”®ç›˜å‡é€Ÿç¨‹åº
  67   1      
  68   1        Key_Val = Key_Read();//å®æ—¶è¯»å–é”®ç å€¼
  69   1        Key_Down = Key_Val & (Key_Old ^ Key_Val);//æ•æ‰æŒ‰é”®ä¸‹é™æ²¿
  70   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);//æ•æ‰æŒ‰é”®ä¸Šé™æ²¿
  71   1        Key_Old = Key_Val;//è¾…åŠ©æ‰«æå˜é‡
  72   1      
  73   1        switch(Key_Down){
  74   2          case 4:
  75   2            if(Run_Status == 0 && (X_Set !=0 | Y_Set != 0)) Run_Status = 1;
  76   2            if(Run_Status == 2 && Wait_Flag == 0) Run_Status = 1;
  77   2            if(Run_Status == 1) Run_Status = 2;
  78   2            break;
  79   2          case 5:
  80   2            if(Run_Status == 0) {X=0;Y=0;}
  81   2            break;
  82   2          case 8:
  83   2            if(++Seg_Mode == 3) Seg_Mode=0;
  84   2            break;
  85   2          case 9:
  86   2            if(Seg_Mode == 2) p_mode = !p_mode;
  87   2            break;
  88   2          case 12:
  89   2            if(Seg_Mode == 2){
  90   3              if(p_mode==0) if(++_R==21) _R=10;
  91   3              if(p_mode==1) if((_B+5)>90) _B=-90;
  92   3            } 
  93   2            break;
  94   2          case 13:
  95   2            if(Seg_Mode == 2){
  96   3              if(p_mode==0) if(--_R==9) _R=20;
  97   3              if(p_mode==1) if((_B-5)<-90) _B=90;
  98   3            } 
  99   2            break;
 100   2      
 101   2        }
 102   1      }
 103          
 104          /* ä¿¡æ¯å¤„ç†å‡½æ•° */
 105          void Seg_Proc()
 106          {
 107   1        if(Seg_Slow_Down<500) return;
 108   1        Seg_Slow_Down = 0;//æ•°ç ç®¡å‡é€Ÿç¨‹åº
 109   1        
 110   1        if(Juli<30) Wait_Flag=1;
 111   1        else Wait_Flag = 0;
 112   1      
 113   1        if(X==X_Set && Y==Y_Set) Arv_Flag=1;
C51 COMPILER V9.54   MAIN                                                                  04/08/2025 20:37:04 PAGE 3   

 114   1        else Arv_Flag=0;
 115   1      
 116   1        if(Arv_Flag==1){
 117   2          if(++L3_Count==6) Arv_Flag=0;
 118   2        }
 119   1      
 120   1        switch(Seg_Mode){
 121   2          case 0:
 122   2            switch(Run_Status){
 123   3              case 0:
 124   3                Seg_Buf[0] = 18;
 125   3                if(X/100%10 != 0) Seg_Buf[1] = X/100%10;
 126   3                else Seg_Buf[1] = 16;
 127   3                if(X/10%10 != 0) Seg_Buf[2] = X/10%10;
 128   3                else Seg_Buf[2] = 16;
 129   3                Seg_Buf[3] = X%10;
 130   3                Seg_Buf[4] = 17;
 131   3                if(Y/100%10 != 0) Seg_Buf[5] = Y/100%10;
 132   3                else Seg_Buf[5] = 16;
 133   3                if(Y/10%10 != 0) Seg_Buf[6] = Y/10%10;
 134   3                else Seg_Buf[6] = 16;
 135   3                Seg_Buf[7] = Y%10;
 136   3                break;
 137   3              case 1:
 138   3              case 2:
 139   3                Seg_Buf[0] = 18;
 140   3                if(X_Set/100%10 != 0) Seg_Buf[1] = X_Set/100%10;
 141   3                else Seg_Buf[1] = 16;
 142   3                if(X_Set/10%10 != 0) Seg_Buf[2] = X_Set/10%10;
 143   3                else Seg_Buf[2] = 16;
 144   3                Seg_Buf[3] = X_Set%10;
 145   3                Seg_Buf[4] = 17;
 146   3                if(Y_Set/100%10 != 0) Seg_Buf[5] = Y_Set/100%10;
 147   3                else Seg_Buf[5] = 16;
 148   3                if(Y_Set/10%10 != 0) Seg_Buf[6] = Y_Set/10%10;
 149   3                else Seg_Buf[6] = 16;
 150   3                Seg_Buf[7] = Y_Set%10;
 151   3                break;
 152   3            }
 153   2            break;
 154   2          case 1:
 155   2            switch(Run_Status){
 156   3              case 0:
 157   3                Seg_Buf[0] = 14;
 158   3                Seg_Buf[1] = 2;
 159   3                Seg_Buf[2] = 16;
 160   3                Seg_Buf[3] = 17;
 161   3                Seg_Buf[4] = 17;
 162   3                Seg_Buf[5] = 17;
 163   3                Seg_Buf[6] = 17;
 164   3                Seg_Buf[7] = 17;
 165   3                break;
 166   3              case 1:
 167   3                Seg_Buf[0] = 14;
 168   3                Seg_Buf[1] = 1;
 169   3                Seg_Buf[2] = 16;
 170   3                if(Speed_Disp/10000%10 != 0) Seg_Buf[3] = Speed_Disp/10000%10;
 171   3                else Seg_Buf[3] = 16;
 172   3                if(Speed_Disp/1000%10 != 0) Seg_Buf[4] = Speed_Disp/1000%10;
 173   3                else Seg_Buf[4] = 16;
 174   3                if(Speed_Disp/100%10 != 0) Seg_Buf[5] = Speed_Disp/100%10;
 175   3                else Seg_Buf[5] = 16;
C51 COMPILER V9.54   MAIN                                                                  04/08/2025 20:37:04 PAGE 4   

 176   3                if(Speed_Disp/10%10 != 0) Seg_Buf[6] = Speed_Disp/10%10 + ',';
 177   3                else Seg_Buf[6] = 16;
 178   3                Seg_Buf[7] = Speed_Disp%10;
 179   3                break;
 180   3              case 2:
 181   3                Seg_Buf[0] = 14;
 182   3                Seg_Buf[1] = 3;
 183   3                Seg_Buf[2] = 16;
 184   3                if(Juli/10000%10 != 0) Seg_Buf[3] = Juli/10000%10;
 185   3                else Seg_Buf[3] = 16;
 186   3                if(Juli/1000%10 != 0) Seg_Buf[4] = Juli/1000%10;
 187   3                else Seg_Buf[4] = 16;
 188   3                if(Juli/100%10 != 0) Seg_Buf[5] = Juli/100%10;
 189   3                else Seg_Buf[5] = 16;
 190   3                if(Juli/10%10 != 0) Seg_Buf[6] = Juli/10%10;
 191   3                else Seg_Buf[6] = 16;
 192   3                Seg_Buf[7] = Juli%10;
 193   3                break;
 194   3            }
 195   2          case 2:
 196   2            Seg_Buf[0] = 19;
 197   2            Seg_Buf[1] = 16;
 198   2            Seg_Buf[2] = _R/10%10 + ',';
 199   2            Seg_Buf[3] = _R%10;
 200   2            Seg_Buf[4] = 16;
 201   2            if(_B<0 && _B/10!=0) Seg_Buf[5] = 17;
 202   2            else Seg_Buf[5] = 16;
 203   2            if(_B<0 && _B/10==0) Seg_Buf[6] = 17;
 204   2            else if(_B/10==0) Seg_Buf[6] = 16;
 205   2            else Seg_Buf[6] = _B/10%10;
 206   2            Seg_Buf[7] = _B%10;
 207   2            break;
 208   2        }
 209   1      
 210   1      }
 211          
 212          /* å…¶ä»–æ˜¾ç¤ºå‡½æ•° */
 213          void Led_Proc()
 214          {
 215   1        if(Run_Status==2) ucLed[0]=Flash_Flag;
 216   1        else ucLed[0]=Run_Status;
 217   1      
 218   1        if(Run_Status==1){
 219   2          if(Night_Flag) ucLed[1]=0;
 220   2          else ucLed[1]=1;
 221   2        }
 222   1        else ucLed[1]=0;
 223   1      
 224   1        ucLed[2]=Arv_Flag;
 225   1      
 226   1      }
 227          
 228          /* ä¸²å£å¤„ç†å‡½æ•° */
 229          void Uart_Proc()
 230          {
 231   1        if(Uart_Slow_Down<10)return;
 232   1        Uart_Slow_Down=0;
 233   1        
 234   1        if (Uart_Rx_Index == 0)
 235   1          return; // æ— æ•°æ®ï¼Œç›´æ¥è¿”å›
 236   1        if (Uart_Recv_Tick >= 10)
 237   1        { // è‹¥æ¥æ”¶è¶…æ—¶ï¼Œå¯¹æ•°æ®è¯»å–ï¼Œæ¸…ç©ºç¼“å­˜åŒº
C51 COMPILER V9.54   MAIN                                                                  04/08/2025 20:37:04 PAGE 5   

 238   2          Uart_Recv_Tick = 0;
 239   2          Uart_Rx_Flag = 0;
 240   2          memset(Uart_Buf, 0, Uart_Rx_Index); // æ¸…ç©ºæ¥æ”¶æ•°æ®
 241   2          Uart_Rx_Index = 0;
 242   2        }
 243   1      }
 244          
 245          /* å®šæ—¶å™¨0ä¸­æ–­åˆå§‹åŒ–å‡½æ•° */
 246          void Timer0Init(void)   //1æ¯«ç§’@12.000MHz
 247          {
 248   1        AUXR &= 0x7F;   //å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼
 249   1        TMOD &= 0xF0;   //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 250   1        TL0 = 0x18;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 251   1        TH0 = 0xFC;   //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 252   1        TF0 = 0;    //æ¸…é™¤TF0æ ‡å¿—
 253   1        TR0 = 1;    //å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
 254   1        ET0 = 1;    //å®šæ—¶å™¨ä¸­æ–­0æ‰“å¼€
 255   1        EA = 1;     //æ€»ä¸­æ–­æ‰“å¼€
 256   1      }
 257          
 258          /* å®šæ—¶å™¨0ä¸­æ–­æœåŠ¡å‡½æ•° */
 259          void Timer0Server() interrupt 1
 260          {  
 261   1        Key_Slow_Down ++;
 262   1        Seg_Slow_Down ++;
 263   1        Uart_Slow_Down++;
 264   1        if(Seg_Slow_Down % 100 == 0) Flash_Flag=!Flash_Flag;
 265   1        if(++Seg_Pos == 8) Seg_Pos = 0;//æ•°ç ç®¡æ˜¾ç¤ºä¸“ç”¨
 266   1         // æ•°ç ç®¡æ˜¾ç¤ºå¤„ç†
 267   1        if (Seg_Buf[Seg_Pos] > 20)
 268   1          Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos] - ',', 1); // å¸¦å°æ•°ç‚¹
 269   1        else
 270   1          Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos], 0); // æ— å°æ•°ç‚¹
 271   1         Led_Disp(ucLed); 
 272   1      }
 273          
 274          /* ä¸²å£1ä¸­æ–­æœåŠ¡å‡½æ•° */
 275          void Uart1Server() interrupt 4
 276          {
 277   1        if(RI == 1) //ä¸²å£æ¥æ”¶æ•°æ®
 278   1        {
 279   2          Uart_Recv[Uart_Recv_Index] = SBUF;
 280   2          Uart_Recv_Index++;
 281   2          RI = 0;
 282   2        }
 283   1      }
 284          
 285          /* Main */
 286          void main()
 287          {
 288   1        System_Init();
 289   1        Timer0Init();
 290   1        UartInit();
 291   1        while (1)
 292   1        {
 293   2          Key_Proc();
 294   2          Seg_Proc();
 295   2          Led_Proc();
 296   2          Uart_Proc();
 297   2        }
 298   1      }

C51 COMPILER V9.54   MAIN                                                                  04/08/2025 20:37:04 PAGE 6   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1411    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     10    ----
   DATA SIZE        =     32    ----
   IDATA SIZE       =     36    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
